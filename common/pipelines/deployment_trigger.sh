#!/bin/bash

##
# Generates a deployment trigger. Adds the `build_image_tag` data
#
# Usage:
#
#     $ ./deployment_trigger.sh <name> <deployment_environment> <cloud_provider> <region> <chart_name>
##


# ARG_OPTIONAL_BOOLEAN([output-only],[],[Do not call buildkite. Used for testing])
# ARG_OPTIONAL_SINGLE([deployment-branches],[],[Branches to deploy],[master])
# ARG_OPTIONAL_SINGLE([private-ops-deployment-branch],[],[Branch of private-ops to use for generic deploys],[master])
# ARG_POSITIONAL_SINGLE([name],[name of the project])
# ARG_POSITIONAL_SINGLE([deployment-environment],[target environment for deployment])
# ARG_POSITIONAL_SINGLE([cloud-provider],[target cloud provider for deployment])
# ARG_POSITIONAL_SINGLE([region],[target region for deployment])
# ARG_POSITIONAL_SINGLE([chart-name],[chart-name to deploy])
# ARG_HELP([Generates a deployment trigger for a given chart to a given target])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output_only="off"
_arg_deployment_branches="master"
_arg_private_ops_deployment_branch="master"


print_help()
{
	printf '%s\n' "Generates a deployment trigger for a given chart to a given target"
	printf 'Usage: %s [--(no-)output-only] [--deployment-branches <arg>] [--private-ops-deployment-branch <arg>] [-h|--help] <name> <deployment-environment> <cloud-provider> <region> <chart-name>\n' "$0"
	printf '\t%s\n' "<name>: name of the project"
	printf '\t%s\n' "<deployment-environment>: target environment for deployment"
	printf '\t%s\n' "<cloud-provider>: target cloud provider for deployment"
	printf '\t%s\n' "<region>: target region for deployment"
	printf '\t%s\n' "<chart-name>: chart-name to deploy"
	printf '\t%s\n' "--output-only, --no-output-only: Do not call buildkite. Used for testing (off by default)"
	printf '\t%s\n' "--deployment-branches: Branches to deploy (default: 'master')"
	printf '\t%s\n' "--private-ops-deployment-branch: Branch of private-ops to use for generic deploys (default: 'master')"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--no-output-only|--output-only)
				_arg_output_only="on"
				test "${1:0:5}" = "--no-" && _arg_output_only="off"
				;;
			--deployment-branches)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_deployment_branches="$2"
				shift
				;;
			--deployment-branches=*)
				_arg_deployment_branches="${_key##--deployment-branches=}"
				;;
			--private-ops-deployment-branch)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_private_ops_deployment_branch="$2"
				shift
				;;
			--private-ops-deployment-branch=*)
				_arg_private_ops_deployment_branch="${_key##--private-ops-deployment-branch=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'name', 'deployment-environment', 'cloud-provider', 'region' and 'chart-name'"
	test "${_positionals_count}" -ge 5 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 5 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 5 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 5 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_name _arg_deployment_environment _arg_cloud_provider _arg_region _arg_chart_name "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash



set -euxo pipefail

# shellcheck disable=SC2154
NAME="$_arg_name"

# shellcheck disable=SC2154
DEPLOYMENT_ENVIRONMENT="$_arg_deployment_environment"

# shellcheck disable=SC2154
CLOUD_PROVIDER="$_arg_cloud_provider"

# shellcheck disable=SC2154
REGION="$_arg_region"

# shellcheck disable=SC2154
CHART_NAME="$_arg_chart_name"

# Setup a temporary directory
pipeline_file="$(mktemp)"

build_image_tag="fake-tag"
# If this isn't only for testing then we set the build_image_tag from buildkite meta-data
if [ "$_arg_output_only" = off ]; then
    build_image_tag=$(buildkite-agent meta-data get "build_image_tag")
fi

cat << EOF > "$pipeline_file"
steps:
  - label: Trigger $NAME ($CHART_NAME chart) deployment to $DEPLOYMENT_ENVIRONMENT
    branches: $_arg_deployment_branches
    trigger: private-ops-deploy-any-chart
    build:
      message: "Deploy $CHART_NAME chart to $DEPLOYMENT_ENVIRONMENT"
      commit: "HEAD"
      branch: "$_arg_private_ops_deployment_branch"
      env:
        ENVIRONMENT: $DEPLOYMENT_ENVIRONMENT
        CLOUD_PROVIDER: $CLOUD_PROVIDER
        REGION: $REGION
        CHART_NAME: $CHART_NAME
        DEPLOY_IMAGE_TAG: $build_image_tag
EOF

if [ "$_arg_output_only" = on ]; then
    cat "$pipeline_file"
else
    buildkite-agent pipeline upload "$pipeline_file"
fi

rm -rf "$pipeline_file"
# ] <-- needed because of Argbash
